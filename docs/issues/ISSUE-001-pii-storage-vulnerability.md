# Issue #1: PII Storage Security Vulnerability

**Severity**: üî¥ Critical
**Component**: Security / PII Tokenizer
**File**: `src/core/execution-engine/security/pii-tokenizer.ts`
**Lines**: 102
**Labels**: `phase-4`, `security`, `critical`, `gdpr`, `compliance`

---

## Problem Description

The `PIITokenizer` class stores original PII values in plaintext in the `reverseMap` for detokenization purposes. This creates a critical security vulnerability where sensitive personal information (emails, phone numbers, SSNs, credit cards) is kept in process memory without encryption.

```typescript
// Line 102 - VULNERABLE CODE
private reverseMap: Map<string, string> = new Map(); // Stores plaintext PII!

// Line 1003
this.reverseMap.set(token, value); // 'value' is original PII in plaintext
```

---

## Impact

**Security**:
- PII exposed in memory dumps
- Visible in debugging sessions and error logs
- Accessible through process inspection tools
- Risk of data breach if process memory is compromised

**Compliance**:
- ‚ùå GDPR violation (Article 32 - Security of processing)
- ‚ùå HIPAA violation (¬ß164.312 - Technical safeguards)
- ‚ùå SOC2 violation (CC6.1 - Logical access controls)
- ‚ùå PCI DSS violation (if credit cards stored)

**Risk Level**: **CRITICAL** - Blocks production deployment

---

## Steps to Reproduce

1. Initialize PIITokenizer: `const tokenizer = new PIITokenizer()`
2. Tokenize PII data: `const result = tokenizer.tokenize("Contact john@example.com")`
3. Inspect memory: `console.log(tokenizer['reverseMap'])`
4. **Observe**: Original email visible in plaintext

---

## Proposed Solutions

### Option 1: Remove Detokenization (Recommended for Security)

Make tokenization one-way only. If PII needs to be retrieved, query it from the original source.

```typescript
export class PIITokenizer {
  private tokenMap: Map<string, PIIToken> = new Map();
  // REMOVE: private reverseMap
  private counters: Map<string, number> = new Map();

  // REMOVE: detokenize() method entirely

  // Keep tokenize() but don't store reverse mapping
  private getOrCreateToken(value: string, type: PIIToken['type']): string {
    const hash = this.hash(value);

    if (this.tokenMap.has(hash)) {
      return this.tokenMap.get(hash)!.token;
    }

    const counter = (this.counters.get(type) || 0) + 1;
    this.counters.set(type, counter);
    const token = `[${type.toUpperCase()}_${counter}]`;

    this.tokenMap.set(hash, { token, type, hashedValue: hash });
    // DO NOT store reverse mapping

    return token;
  }
}
```

**Pros**: Maximum security, GDPR compliant
**Cons**: Cannot detokenize (may need alternative approach for some use cases)

---

### Option 2: Encrypt Reverse Map

Encrypt PII values before storing in reverse map using AES-256.

```typescript
import crypto from 'crypto';

export class PIITokenizer {
  private encryptionKey: Buffer;
  private tokenMap: Map<string, PIIToken> = new Map();
  private reverseMap: Map<string, string> = new Map(); // Now stores ENCRYPTED values
  private counters: Map<string, number> = new Map();

  constructor(encryptionKey?: Buffer) {
    // Generate or use provided encryption key
    this.encryptionKey = encryptionKey || crypto.randomBytes(32);
  }

  private encrypt(plaintext: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-gcm', this.encryptionKey, iv);

    let encrypted = cipher.update(plaintext, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const authTag = cipher.getAuthTag();

    return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted;
  }

  private decrypt(ciphertext: string): string {
    const parts = ciphertext.split(':');
    const iv = Buffer.from(parts[0], 'hex');
    const authTag = Buffer.from(parts[1], 'hex');
    const encrypted = parts[2];

    const decipher = crypto.createDecipheriv('aes-256-gcm', this.encryptionKey, iv);
    decipher.setAuthTag(authTag);

    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  private getOrCreateToken(value: string, type: PIIToken['type']): string {
    const hash = this.hash(value);

    if (this.tokenMap.has(hash)) {
      return this.tokenMap.get(hash)!.token;
    }

    const counter = (this.counters.get(type) || 0) + 1;
    this.counters.set(type, counter);
    const token = `[${type.toUpperCase()}_${counter}]`;

    this.tokenMap.set(hash, { token, type, hashedValue: hash });
    this.reverseMap.set(token, this.encrypt(value)); // Store ENCRYPTED

    return token;
  }

  detokenize(text: string): string {
    let detokenized = text;

    for (const [token, encryptedValue] of this.reverseMap.entries()) {
      const value = this.decrypt(encryptedValue); // Decrypt on use
      detokenized = detokenized.split(token).join(value);
    }

    return detokenized;
  }
}
```

**Pros**: Maintains detokenization functionality, GDPR compliant
**Cons**: More complex, requires key management, slight performance overhead

---

### Option 3: Use Secure Enclave/Key Vault

Store PII in a secure key vault (AWS KMS, Azure Key Vault, HashiCorp Vault) and only keep references.

```typescript
export class PIITokenizer {
  private vaultClient: VaultClient;
  private tokenMap: Map<string, PIIToken> = new Map();
  private reverseMap: Map<string, string> = new Map(); // Stores vault keys, not PII
  private counters: Map<string, number> = new Map();

  constructor(vaultClient: VaultClient) {
    this.vaultClient = vaultClient;
  }

  private async getOrCreateToken(value: string, type: PIIToken['type']): Promise<string> {
    const hash = this.hash(value);

    if (this.tokenMap.has(hash)) {
      return this.tokenMap.get(hash)!.token;
    }

    const counter = (this.counters.get(type) || 0) + 1;
    this.counters.set(type, counter);
    const token = `[${type.toUpperCase()}_${counter}]`;

    // Store PII in vault
    const vaultKey = await this.vaultClient.store(value);

    this.tokenMap.set(hash, { token, type, hashedValue: hash });
    this.reverseMap.set(token, vaultKey); // Store vault key, not PII

    return token;
  }

  async detokenize(text: string): Promise<string> {
    let detokenized = text;

    for (const [token, vaultKey] of this.reverseMap.entries()) {
      const value = await this.vaultClient.retrieve(vaultKey); // Get from vault
      detokenized = detokenized.split(token).join(value);
    }

    return detokenized;
  }
}
```

**Pros**: Maximum security, GDPR compliant, centralized key management
**Cons**: Requires external service, increased latency, more complex

---

## Recommended Approach

**Option 1** (Remove detokenization) is recommended for Phase 4 because:

1. **Simplest and most secure** - No encryption keys to manage
2. **Fully GDPR compliant** - PII never stored in application memory
3. **Fastest performance** - No encryption/decryption overhead
4. **Lowest risk** - Impossible to leak what you don't store

If detokenization is absolutely required for specific use cases, implement **Option 2** (encryption) as a secondary path.

---

## Acceptance Criteria

- [ ] Plaintext PII never stored in application memory
- [ ] All existing tests pass
- [ ] New security tests added:
  - [ ] Verify `reverseMap` doesn't contain plaintext
  - [ ] Test memory inspection shows no PII
  - [ ] Verify tokens are one-way only (if Option 1)
- [ ] Security review completed and approved
- [ ] Compliance review completed (GDPR, HIPAA, SOC2)
- [ ] Documentation updated
- [ ] Migration guide created if detokenize() removed

---

## Testing Requirements

### Unit Tests
```typescript
describe('PIITokenizer Security', () => {
  it('should not store plaintext PII in memory', () => {
    const tokenizer = new PIITokenizer();
    tokenizer.tokenize('secret@email.com');

    // Inspect internal state
    const internalState = JSON.stringify(tokenizer);
    expect(internalState).not.toContain('secret@email.com');
  });

  it('should not expose PII through error messages', () => {
    const tokenizer = new PIITokenizer();
    tokenizer.tokenize('555-1234');

    expect(() => {
      // Trigger error
      throw new Error(JSON.stringify(tokenizer));
    }).not.toThrow(/555-1234/);
  });
});
```

### Security Tests
- [ ] Memory dump analysis (no plaintext PII)
- [ ] Process inspection resistance
- [ ] Error log sanitization verification
- [ ] Compliance audit scan

---

## Related Issues

- Issue #14: Unsalted PII Hash (related to hash security)
- Issue #8: Unsafe PII Tokenization (related to usage patterns)

---

## References

- GDPR Article 32: https://gdpr-info.eu/art-32-gdpr/
- OWASP Sensitive Data Exposure: https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure
- NIST Cryptographic Standards: https://csrc.nist.gov/publications/fips

---

**Priority**: üî• CRITICAL - BLOCKS PRODUCTION
**Estimated Effort**: 4 hours (Option 1), 8 hours (Option 2), 16 hours (Option 3)
**Risk if not fixed**: Data breach, regulatory fines, loss of customer trust
